package com.db.springhello.services;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTCreator;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import org.apache.commons.lang3.time.DateUtils;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;

import javax.servlet.http.HttpServletRequest;
import java.sql.Timestamp;
import java.util.Date;
import java.util.StringTokenizer;

@Service
public class JWTTokenService {

    private final String jwtIssuer = "SpringGoodbyeApplication";
    private final String password = "passwd_wh!ch_never_le@ves_the_s3rv3r";
    private final Algorithm algorithm;
    private final int LOGIN_EXPIRE_DAYS = 7;

    public JWTTokenService() {
        algorithm = Algorithm.HMAC256(password);
    }

    public JWTCreator.Builder generateToken(int expireDays, int role) { // tight coupling
        JWTCreator.Builder jwtBuilder = JWT.create();
        Algorithm jwtAlgorithm = Algorithm.HMAC256(password);
        Date nowDate = new Date();
        Date expireDate = DateUtils.addDays(nowDate, expireDays);
        return jwtBuilder.withIssuedAt(new Timestamp(nowDate.getTime()))
                .withIssuer("SpringGoodbyeApplication")
                .withExpiresAt(expireDate).withClaim("role", role);
    }
    public JWTCreator.Builder generateToken(int role) {
        return generateToken(LOGIN_EXPIRE_DAYS, role);
    }

    public JWTCreator.Builder generateToken(DecodedJWT decodedJWT) { // tight coupling
        JWTCreator.Builder jwtBuilder = JWT.create();
        Date nowDate = decodedJWT.getIssuedAt();
        Date expireDate = decodedJWT.getExpiresAt();
        return jwtBuilder.withIssuedAt(new Timestamp(nowDate.getTime()))
                .withIssuer(jwtIssuer)
                .withExpiresAt(expireDate).withClaim("role", decodedJWT.getClaim("role").toString());
    }

    public String signToken(JWTCreator.Builder builder) {
        return builder.sign(algorithm);
    }


    public String extractToken(HttpServletRequest request) {
        String authorization = request.getHeader("Authorization");
        if (authorization == null) return null;
        StringTokenizer stringTokenizer = new StringTokenizer(authorization, " ");
        String authType, jwtToken = "";
        if(stringTokenizer.hasMoreTokens()) {
            authType = stringTokenizer.nextToken(); // "Bearer"
        }
        if(stringTokenizer.hasMoreTokens()) {
            jwtToken = stringTokenizer.nextToken(); // jwt token
        }
        if (jwtToken.length() == 0) return null;
        return jwtToken;
    }

    private boolean verifyIssuer(DecodedJWT decodedJWT) {
        String issuer = decodedJWT.getIssuer();
        if (issuer.compareTo(jwtIssuer) != 0) {
            System.err.println("Received a token which was not generated by our server");
            return false;
        }
        return true;
    }

    private boolean sameSignature(DecodedJWT decodedJWT) {
        JWTCreator.Builder jwtBuilder = this.generateToken(decodedJWT);
        String newToken = this.signToken(jwtBuilder.withSubject(decodedJWT.getSubject()));
        DecodedJWT newTokenDecoded = this.decodeToken(newToken);
        String newTokenSignature = newTokenDecoded.getSignature();
        String oldTokenSignature = decodedJWT.getSignature(); // ?
        System.out.println("Old token signature: " + oldTokenSignature);
        System.out.println("New token signature: " + newTokenSignature);
        return oldTokenSignature.compareTo(newTokenSignature) == 0;
    }

    private boolean checkNotExpired(DecodedJWT decodedJWT) {
        Date expiresAt = decodedJWT.getExpiresAt();
        Date nowDate = new Date();
        if (nowDate.compareTo(expiresAt) > 0) { // nowDate > expiresAt
            return false;
        }
        return true; // not expired == available
    }

    public boolean verifyToken(DecodedJWT decodedJWT) {
        return sameSignature(decodedJWT) && verifyIssuer(decodedJWT) && checkNotExpired(decodedJWT);
    }

    public DecodedJWT decodeToken(String token) {
        return JWT.decode(token);
    }

}
